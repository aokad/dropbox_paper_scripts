#! /usr/bin/env python3
import sys
import csv
import argparse
import gzip
class SiteStats:
    def __init__(self, g_size, g_seq):
        self.num_reads = 0
        self.called_sites = 0
        self.called_sites_methylated = 0
        self.group_size = g_size
        self.sequence = g_seq
def update_call_stats(key, sites, num_called_cpg_sites, is_methylated, sequence):
    if key not in sites:
        sites[key] = SiteStats(num_called_cpg_sites, sequence)
    sites[key].num_reads += 1
    sites[key].called_sites += num_called_cpg_sites
    if is_methylated > 0:
        sites[key].called_sites_methylated += num_called_cpg_sites
def dump_keys(sites, hout):
    sorted_keys = sorted(list(sites.keys()), key = lambda x: x)
    for key in sorted_keys:
        if sites[key].called_sites > 0:
            (c, s, e) = key
            f = float(sites[key].called_sites_methylated) / sites[key].called_sites
            print("%s\t%s\t%s\t%d\t%d\t%d\t%.3f\t%s" % (c, s, e, sites[key].group_size, sites[key].called_sites, sites[key].called_sites_methylated, f, sites[key].sequence), file = hout)
def read_haplotag(haplotag_file):
    read2tag = {}    
    with open(haplotag_file, 'r') as hin:
        for line in hin:
            F = line.rstrip('\n').split('\t')
            read2tag[F[0]] = F[1]
    return(read2tag)
def main(args):
    read2tag = read_haplotag(args.haplotag_file)
    sites = dict()
    sites1 = dict()
    sites2 = dict()
    temp_chr = ''
    total_output_file = args.output_prefix + ".total.txt"
    tag1_output_file = args.output_prefix + ".tag1.txt"
    tag2_output_file = args.output_prefix + ".tag2.txt"
    hout = open(total_output_file, 'w')
    hout1 = open(tag1_output_file, 'w')
    hout2 = open(tag2_output_file, 'w')
    print("\t".join(["chromosome", "start", "end", "num_motifs_in_group", "called_sites", "called_sites_methylated", "methylated_frequency", "group_sequence"]), file = hout)
    print("\t".join(["chromosome", "start", "end", "num_motifs_in_group", "called_sites", "called_sites_methylated", "methylated_frequency", "group_sequence"]), file = hout1)
    print("\t".join(["chromosome", "start", "end", "num_motifs_in_group", "called_sites", "called_sites_methylated", "methylated_frequency", "group_sequence"]), file = hout2)
    input_file = args.input_file
    if input_file[-3:] == ".gz":
        in_fh = gzip.open(input_file, 'rt')
    else:
        in_fh = open(input_file, 'r')
    csv_reader = csv.DictReader(in_fh, delimiter='\t')
    for record in csv_reader:
        if temp_chr != record['chromosome']:
            """
            dump_keys(sites, hout)
            dump_keys(sites1, hout1)
            dump_keys(sites2, hout2)
            sites = dict()
            sites1 = dict()
            sites2 = dict()
            """
            print("Complete %s" % temp_chr, file = sys.stderr)
            temp_chr = record['chromosome']
        num_sites = int(record['num_motifs'])
        llr = float(record['log_lik_ratio'])
        # Skip ambiguous call
        if abs(llr) < args.call_threshold * num_sites:
            continue
        sequence = record['sequence']
        is_methylated = llr > 0
        key = (str(record['chromosome']), int(record['start']), int(record['end']))
        update_call_stats(key, sites, num_sites, is_methylated, sequence)
        if record["read_name"] in read2tag: 
            if read2tag[record["read_name"]] == 'H1':
                update_call_stats(key, sites1, num_sites, is_methylated, sequence)
            elif read2tag[record["read_name"]] == 'H2':
                update_call_stats(key, sites2, num_sites, is_methylated, sequence)
    dump_keys(sites, hout)
    dump_keys(sites1, hout1)
    dump_keys(sites2, hout2)
    in_fh.close()
    hout.close()
    hout1.close()
    hout2.close()
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Calculate methylation frequency at genomic CpG sites')
    parser.add_argument("input_file", help = "methylation file generated by nanopolish", type = str)
    parser.add_argument("haplotag_file", help = "haplotag file generated by whatshap", type = str)
    parser.add_argument("output_prefix", help = "output prefix name", type = str) 
    parser.add_argument('-c', '--call-threshold', type=float, required=False, default=2.0)
    args = parser.parse_args()
    # assert(args.call_threshold is not None)
    main(args)

